---
title: "91解码方法"
date: 2020-11-09T17:05:35+08:00
draft: false 
tags: ["字符串","动态规划","leetcode-medium"]   #[]前面要有空格
---

# 题目

一条包含字母 `A-Z` 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

给定一个只包含数字的**非空**字符串，请计算解码方法的总数。

题目数据保证答案肯定是一个 32 位的整数。

 

**示例 1：**

```
输入："12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2：**

```
输入："226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

**示例 3：**

```
输入：s = "0"
输出：0
```

**示例 4：**

```
输入：s = "1"
输出：1
```

**示例 5：**

```
输入：s = "2"
输出：1
```

# 解答

我们来随意看一个编码 22424231322，如果这个字符串需要解码的话，它可以由一下两种可能组成

- 2 和 解码 2242423132 的结果
-  22 和 解码 24242313 的结果

当然如果是这样的一个编码 22424231332，那么就只有一种情况了

- 2 和 解码 2242423133的结果

那么这重形式显然是一种动态迁移的过程，所以我们可以用动态规划来解决这个问题。

dp\[i\] = dp\[i-1\] + dp\[i-2\]  当 s[i-1] 和 s[i]  的数值小于 26 ,且s\[i\] 的值大于0 

dp\[i\] = dp\[i-1\]  当 s[i-1] 和 s[i]  的大于 26 ,且s\[i\] 的值大于0 



```go
func numDecodings(s string) int {
   if len(s) == 0 {
		return 0
	}
	
	if !(s[0] >= '1' && s[0] <= '9') {
		return 0 
	} 


	dp := make([]int,len(s)+1)

	dp[0] = 1
	dp[1] = 1



	for i := 2;i<=len(s);i++ {
		low := s[i-1] - '0'
		high := s[i-2] - '0'
		
		if low > 0 {
			dp[i] += dp[i-1]
		}
		v := high * 10 + low
		
		if v >= 10 && v <= 26 {
			dp[i] += dp[i-2]	
		}else if low == 0 { // low is 0 and high is 0 
			return 0 
		}
	}

	return dp[len(s)]
}
```



时间复杂度 $ O(n) $

空间复杂度 $ O(n) $



这个题目很简单,但是在处理0的时候被坑了几次,
一开始没注意0这种情况
但是后来又考虑的比较简单,所以错了几次.
主要有以下几种情况:

1. 非法输入
   开头的0,连续的00,都无法有效解码
2. 中间出现的0,
   10是合法的,30不合法,101注意不满足第二种拆分情况,因为01不是有效编码