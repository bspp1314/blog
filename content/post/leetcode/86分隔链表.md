---
title: "86分隔链表"
date: 2020-08-30T22:24:49+08:00
draft: false
tags: ["双指针","链表","leetcode-medium"]   #[]前面要有空格
categories: ["leetcode"]
---

# 题目

给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。<!--more-->

你应当保留两个分区中每个节点的初始相对位置。




示例:
```
输入: head = 1->4->3->2->5->2, x = 3
输出: 1->2->2->4->3->5
```



# 解答

一个典型的双指针题目，个人一看到这个题目就想到了用快慢指针来处理，其代码如下

```go
func partition(head *ListNode, x int) *ListNode {
	//  4-> 4 -> 3 -> 2 ->5 ->2
	if head == nil || head.Next == nil {
		return head
	}

	var slow *ListNode
	var fast2 *ListNode
	fast := head.Next
	fast2 = head
	if fast2.Val < x {
		slow = head
	}

	for fast != nil {
		if fast.Val >= x {
			fast2 = fast
			fast = fast.Next
			continue
		}

		if fast2.Val < x {
			fast2 = fast
			fast = fast2.Next
			slow = fast2
			continue
		}

		tem := fast
		fast2.Next = fast.Next
		fast = fast2.Next
		tem.Next = nil

		if slow == nil {
			tem.Next = head
			slow = tem
			head = slow
		} else {
			tem.Next = slow.Next
			slow.Next = tem
			slow = slow.Next
		}
	}

	return head
}
```

时间复杂度 $ O(n) $

空间复杂度 $ O(1) $



虽然上述代码的时间复杂度和空间复杂度都是最优解，不过说实话代码的判定条件实在太多，很容易出错，在看了官方题解之后，发现官方的题解更容易理解，通过将链表拆成两个链表并加上哨兵节点就可以很优雅的实现代码了。

```go
func partition2(head *ListNode, x int) *ListNode {
	p1Head := &ListNode{}
	p2Head := &ListNode{}

	p1 := p1Head
	p2 := p2Head

	for head != nil {
		if head.Val < x {
			p1.Next = head
			head = head.Next
			p1 = p1.Next
			p1.Next = nil
		} else {
			p2.Next = head
			head = head.Next
			p1 = p1.Next
			p1.Next = nil
		}
	}

	p1.Next = p2Head.Next
	return p1Head.Next
}
```

时间复杂度 $ O(n) $

空间复杂度 $ O(1) $

