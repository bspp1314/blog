---
title: "303区域和检索 数组不可变"
date: 2020-11-23T21:28:29+08:00
draft: false
tags: ["动态规划","leetcode-easy"]   #[]前面要有空格
categories: ["leetcode"]
---

#### # 题目

难度简单210收藏分享切换为英文接收动态反馈

给定一个整数数组  `nums`，求出数组从索引 `i` 到 `j`*（*`i ≤ j`）范围内元素的总和，包含 `i`、`j `两点。

实现 `NumArray` 类：

- `NumArray(int[] nums)` 使用数组 `nums` 初始化对象
- `int sumRange(int i, int j)` 返回数组 `nums` 从索引 `i` 到 `j`*（*`i ≤ j`）范围内元素的总和，包含 `i`、`j `两点（也就是 `sum(nums[i], nums[i + 1], ... , nums[j])`）

 

**示例：**

```
输入：
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
输出：
[null, 1, -1, -3]

解释：
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
```





# 题目

这个是一个动态规划的题目，我们dp表示前i个数的和，那么i - j 区间的和就是
$$
sum[i,j] = dp[j] - dp[i-1]
$$

```go
type NumArray struct {
	Dp   []int
	Nums []int
}


func Constructor(nums []int) NumArray {
	dp := make([]int,len(nums))
	if len(nums) == 0 {
		return NumArray{}
	}
	dp[0] = nums[0]
	for i := 1;i<len(nums);i++ {
		dp[i]  = dp[i-1] + nums[i]
	}
	return NumArray{
		Dp:   dp,
		Nums: nums,
	}
}

func (this *NumArray) SumRange(i int, j int) int {
	if len(this.Nums) == 0 {
		return 0
	}

	if i == 0 {
		return this.Dp[j]
	}else{

	}

	return this.Dp[j] - this.Dp[i-1]
}
```

时间复杂度 $ O(n) $

空间复杂度 $ O(n) $

