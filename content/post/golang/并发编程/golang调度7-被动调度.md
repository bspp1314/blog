---
title: "golang调度7-被动调度"
date: 2021-02-05T14:32:05+08:00
draft: true
---

之前分析了调度器的调度策略，即调度器如何选取下一个进入运行的goroutine，但我们还不清楚什么时候以及什么情况下会发生调度。总体说来，go语言的调度器会在以下三种情况下对goroutine进行调度：

1. goroutine执行某个操作因条件不满足需要等待而发生的调度；
2. goroutine主动调用Gosched()函数让出CPU而发生的调度；
3. goroutine运行时间太长或长时间处于系统调用之中而被调度器剥夺运行权而发生的调度。



以一个demo程序为例来分析因阻塞而发生的被动调度

```go
package main
 
func start(c chan int) {
    c<-100
}
 
func main() {
    c:=make(chan int)
 
    go start(c)
 
    <-c
}
```



从上面的代码中我们可以知道当 main 运行 <-c 的时候 main groutine 会进入阻塞,我们通过dlv 来查看 <-c 会调用哪个函数

```go
 dlv debug main.go 
Type 'help' for list of commands.
(dlv) break main.main
Breakpoint 1 set at 0x106620f for main.main() ./main.go:8
(dlv) c
> main.main() ./main.go:8 (hits goroutine(1):1 total:1) (PC: 0x106620f)
     3: func start(c chan int)  {
     4:         c <- 100
     5: 
     6: }
     7: 
=>   8: func main() {
     9:         c := make(chan int)
    10:         go start(c)
    11:         <-c
    12: }
(dlv) disassemble
TEXT main.main(SB) /Users/linyuanpeng/workplace/go/src/github.com/bspp1314/go-common-lib/sched-lib/ex5/main.go
        main.go:8               0x1066200       65488b0c2530000000      mov rcx, qword ptr gs:[0x30]
        main.go:8               0x1066209       483b6110                cmp rsp, qword ptr [rcx+0x10]
        main.go:8               0x106620d       7671                    jbe 0x1066280
=>      main.go:8               0x106620f*      4883ec28                sub rsp, 0x28
        main.go:8               0x1066213       48896c2420              mov qword ptr [rsp+0x20], rbp
        main.go:8               0x1066218       488d6c2420              lea rbp, ptr [rsp+0x20]
        main.go:9               0x106621d       488d051c6d0000          lea rax, ptr [rip+0x6d1c]
        main.go:9               0x1066224       48890424                mov qword ptr [rsp], rax
        main.go:9               0x1066228       48c744240800000000      mov qword ptr [rsp+0x8], 0x0
        main.go:9               0x1066231       e80adbf9ff              call $runtime.makechan
        main.go:9               0x1066236       488b442410              mov rax, qword ptr [rsp+0x10]
        main.go:9               0x106623b       4889442418              mov qword ptr [rsp+0x18], rax
        main.go:10              0x1066240       c7042408000000          mov dword ptr [rsp], 0x8
        main.go:10              0x1066247       488d0d3aa80100          lea rcx, ptr [rip+0x1a83a]
        main.go:10              0x106624e       48894c2408              mov qword ptr [rsp+0x8], rcx
        main.go:10              0x1066253       4889442410              mov qword ptr [rsp+0x10], rax
        main.go:10              0x1066258       e88364fdff              call $runtime.newproc
        main.go:11              0x106625d       488b442418              mov rax, qword ptr [rsp+0x18]
        main.go:11              0x1066262       48890424                mov qword ptr [rsp], rax
        main.go:11              0x1066266       48c744240800000000      mov qword ptr [rsp+0x8], 0x0
        main.go:11              0x106626f       e8cce8f9ff              call $runtime.chanrecv1
        main.go:12              0x1066274       488b6c2420              mov rbp, qword ptr [rsp+0x20]
        main.go:12              0x1066279       4883c428                add rsp, 0x28
        main.go:12              0x106627d       c3                      ret
        main.go:8               0x106627e       6690                    data16 nop
        main.go:8               0x1066280       e81bb2ffff              call $runtime.morestack_noctxt
        <autogenerated>:1       0x1066285       e976ffffff              jmp $main.main
(dlv) 

```

 从汇编码我们可以看出 <-c 会被翻译成 runtime.chanrecv1

```go
// entry points for <- c from compiled code
//go:nosplit
func chanrecv1(c *hchan, elem unsafe.Pointer) {
	chanrecv(c, elem, true)
}

// runtime/chan.go : 415
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
    ......
    //省略部分的代码逻辑主要在判断读取操作是否可以立即完成，如果不能立即完成
    //就需要把g挂在channel c的读取队列上，然后调用goparkunlock函数阻塞此goroutine
    goparkunlock(&c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)
  	//以下部门是g被唤醒之后的操作，这里先忽略
    ......
}

```

chanrecv1直接调用chanrecv函数实现读取操作，chanrecv首先会判断channel是否有数据可读，如果有数据则直接读取并返回，但如果没有数据，则需要把当前goroutine挂入channel的读取队列之中并调用goparkunlock函数阻塞该goroutine.



```go
// Puts the current goroutine into a waiting state and unlocks the lock.
// The goroutine can be made runnable again by calling goready(gp).
func goparkunlock(lock *mutex, reason waitReason, traceEv byte, traceskip int) {
	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
}

// Puts the current goroutine into a waiting state and calls unlockf.
// If unlockf returns false, the goroutine is resumed.
// unlockf must not access this G's stack, as it may be moved between
// the call to gopark and the call to unlockf.
// Reason explains why the goroutine has been parked.
// It is displayed in stack traces and heap dumps.
// Reasons should be unique and descriptive.
// Do not re-use reasons, add new ones.
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {
	if reason != waitReasonSleep {
		checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy
	}
	mp := acquirem()
	gp := mp.curg
	status := readgstatus(gp)
	if status != _Grunning && status != _Gscanrunning {
		throw("gopark: bad g status")
	}
	mp.waitlock = lock
	mp.waitunlockf = unlockf
	gp.waitreason = reason
	mp.waittraceev = traceEv
	mp.waittraceskip = traceskip
	releasem(mp)
	// can't do anything that might move the G between Ms here.
	mcall(park_m)
}



```

goparkunlock函数直接调用gopark函数，gopark则调用mcall从当前main goroutine切换到g0去执行park_m函数（mcall前面我们分析过，其主要作用就是保存当前goroutine的现场，然后切换到g0栈去调用作为参数传递给它的函数）

```go
// park continuation on g0.
func park_m(gp *g) {
  //g0 栈
	_g_ := getg()

	if trace.enabled {
		traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)
	}

	casgstatus(gp, _Grunning, _Gwaiting)
  //解除g和m之间的关系
	dropg()

	....
  //进入调度
  // park_m首先把当前goroutine的状态设置为_Gwaiting（因为它正在等待其它goroutine往channel里面写数据），然后调用dropg函数解除g和m之间的关系，最后通过调用schedule函数进入调度循环，
	schedule()
}

```



##  唤醒阻塞在channel上的goroutine

```go
(dlv) break main.start
Breakpoint 2 set at 0x10661af for main.start() ./main.go:3
(dlv) c
> main.start() ./main.go:3 (hits goroutine(5):1 total:1) (PC: 0x10661af)
     1: package main
     2: 
=>   3: func start(c chan int)  {
     4:         c <- 100
     5: 
     6: }
     7: 
     8: func main() {
(dlv) disassemble
TEXT main.start(SB) /Users/linyuanpeng/workplace/go/src/github.com/bspp1314/go-common-lib/sched-lib/ex5/main.go
        main.go:3               0x10661a0       65488b0c2530000000      mov rcx, qword ptr gs:[0x30]
        main.go:3               0x10661a9       483b6110                cmp rsp, qword ptr [rcx+0x10]
        main.go:3               0x10661ad       7632                    jbe 0x10661e1
=>      main.go:3               0x10661af*      4883ec18                sub rsp, 0x18
        main.go:3               0x10661b3       48896c2410              mov qword ptr [rsp+0x10], rbp
        main.go:3               0x10661b8       488d6c2410              lea rbp, ptr [rsp+0x10]
        main.go:4               0x10661bd       488b442420              mov rax, qword ptr [rsp+0x20]
        main.go:4               0x10661c2       48890424                mov qword ptr [rsp], rax
        main.go:4               0x10661c6       488d056be20100          lea rax, ptr [rip+0x1e26b]
        main.go:4               0x10661cd       4889442408              mov qword ptr [rsp+0x8], rax
        main.go:4               0x10661d2       e8a9def9ff              call $runtime.chansend1
        main.go:6               0x10661d7       488b6c2410              mov rbp, qword ptr [rsp+0x10]
        main.go:6               0x10661dc       4883c418                add rsp, 0x18
        main.go:6               0x10661e0       c3                      ret
        main.go:3               0x10661e1       e8bab2ffff              call $runtime.morestack_noctxt
        <autogenerated>:1       0x10661e6       ebb8                    jmp $main.start
(dlv) 

```

同样我们通过dlv 可以看到 c<-100 会调动函数 runtime.chansend1



```go
// entry point for c <- x from compiled code
//go:nosplit
func chansend1(c *hchan, elem unsafe.Pointer) {
    chansend(c, elem, true, getcallerpc())
}

func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
	.......

	if sg := c.recvq.dequeue(); sg != nil {
		// Found a waiting receiver. We pass the value we want to send
		// directly to the receiver, bypassing the channel buffer (if any).
		send(c, sg, ep, func() { unlock(&c.lock) }, 3)
		return true
	}

	......
}

func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
    ......
    goready(gp, skip+1)
}

func goready(gp *g, traceskip int) {
    systemstack(func() {
        ready(gp, traceskip, true)
    })
}

```

> channel发送和读取的流程类似，如果能够立即发送则立即发送并返回，如果不能立即发送则需要阻塞，在我们这个场景中，因为main goroutine此时此刻正挂在channel的读取队列上等待数据，所以这里直接调用send函数发送给main goroutine，send函数则调用goready函数切换到g0栈并调用ready函数来唤醒sg对应的goroutine，即正在等待读channel的main goroutine。

```go
// Mark gp ready to run.
func ready(gp *g, traceskip int, next bool) {
	if trace.enabled {
		traceGoUnpark(gp, traceskip)
	}

	status := readgstatus(gp)

	// Mark runnable.
	_g_ := getg()
	mp := acquirem() // disable preemption because it can be holding p in a local var
	if status&^_Gscan != _Gwaiting {
		dumpgstatus(gp)
		throw("bad g->status in ready")
	}

	// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq
  // 把需要唤醒的goroutine的状态设置为_Grunnable
	casgstatus(gp, _Gwaiting, _Grunnable)
	//然后把其放入运行队列之中等待调度器的调度。
  runqput(_g_.m.p.ptr(), gp, next)
  //有空闲的p而且没有正在偷取goroutine的工作线程，则需要唤醒p出来工作
	wakep()
	releasem(mp)
}
```

执行到这里main goroutine已经被放入了运行队列，但还未被调度起来运行，而g2 goroutine在向channel写完数据之后就从这里的ready函数返回并退出了.g2的退出过程中将会在goexit0函数中调用schedule函数进入下一轮调度，从而把刚刚放入运行队列的main goroutine调度起来运行。



# 唤醒空闲的P

```go
// Tries to add one more P to execute G's.
// Called when a G is made runnable (newproc, ready).
func wakep() {
  //查看空闲的 p  是否为0 
	if atomic.Load(&sched.npidle) == 0 {
		return
	}
	// be conservative about spinning threads
  // atomic.Load(&sched.nmspinning) 如果已经有工作线程进入了spinning状态而在四处寻找需要运行的goroutine 
  if atomic.Load(&sched.nmspinning) != 0 || !atomic.Cas(&sched.nmspinning, 0, 1) {
		return
	}
  //唤醒M
	startm(nil, true)
}

```





```go
// Schedules some M to run the p (creates an M if necessary).
// If p==nil, tries to get an idle P, if no idle P's does nothing.
// May run with m.p==nil, so write barriers are not allowed.
// If spinning is set, the caller has incremented nmspinning and startm will
// either decrement nmspinning or set m.spinning in the newly started M.
//go:nowritebarrierrec
func startm(_p_ *p, spinning bool) {
	lock(&sched.lock)
  //没有指定p的话需要从p的空闲队列中获取一个p
	if _p_ == nil {
		_p_ = pidleget() //从p的空闲队列中获取空闲p
		if _p_ == nil {
			unlock(&sched.lock)
			if spinning {
				// The caller incremented nmspinning, but there are no idle Ps,
				// so it's okay to just undo the increment and give up.
				if int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {
					throw("startm: negative nmspinning")
				}
			}
			return //没有空闲的p，直接返回
		}
	}
  //从m空闲队列中获取正处于睡眠之中的工作线程，所有处于睡眠状态的m都在此队列中
	mp := mget()
	if mp == nil {
		// No M is available, we must drop sched.lock and call newm.
		// However, we already own a P to assign to the M.
		//
		// Once sched.lock is released, another G (e.g., in a syscall),
		// could find no idle P while checkdead finds a runnable G but
		// no running M's because this new M hasn't started yet, thus
		// throwing in an apparent deadlock.
		//
		// Avoid this situation by pre-allocating the ID for the new M,
		// thus marking it as 'running' before we drop sched.lock. This
		// new M will eventually run the scheduler to execute any
		// queued G's.
		id := mReserveID()
		unlock(&sched.lock)

		var fn func()
		if spinning {
			// The caller incremented nmspinning, so set m.spinning in the new M.
			fn = mspinning
		}
    //创建M
		newm(fn, _p_, id)
		return
	}
	unlock(&sched.lock)
	if mp.spinning {
		throw("startm: m is spinning")
	}
	if mp.nextp != 0 {
		throw("startm: m has p")
	}
	if spinning && !runqempty(_p_) {
		throw("startm: p has runnable gs")
	}
	// The caller incremented nmspinning, so set m.spinning in the new M.
	mp.spinning = spinning
	//设置P
  mp.nextp.set(_p_)
  //唤醒M
	notewakeup(&mp.park)
}

```









