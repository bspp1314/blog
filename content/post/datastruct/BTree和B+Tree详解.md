---
title: "BTree和B+Tree详解"
date: 2020-10-04T23:06:48+08:00
draft: false 
---

# 概述

B 树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡二叉树。B树类似于红黑树，但它们在减低磁盘I/O操作方面效率会更高。许多数据库系统使用BTree或者B树的变种。



# B 树的定义

一颗B树T是具有以下性质的有根树（根为T.root）

- 每个节点 $ x $ 有一下性质

  1. $ x.n $,当前存储在节点x中的关键字个数

  2. $ x.n $ 个关键字本身 $ x.key_{1},x.key_{2},....., x.key_{x.n} $ 以非降序存放，使得$ x.key_{1} <= x.key_{2}<=..... <= x.key_{x.n} $ 
  3. $ x.leaf $ 是一个布尔值，如果 x  是 叶节点，则为true,如果x为内部节点，则为false 

- 每个节点内部还包含 $ x.n+1 $ 个指向其孩子的指针 $ x.c_1, x.c_2,......, x.c_{n+1} $。叶节点没有孩子，所以他们没有 $ c_i $ 属性定义

- 关键字  $ x.key_i $ 对存储在各个子树中的关键字范围进行分割：如果 $ k_i $ 为任意存储在以 $ x.c_i $ 为 根的子树的关键字，那么 
  $$
  k1 <= x.key_1 <= k2 <= x.key_2 <= ... <= x.key_{x.n} <= k_{x.n+1}
  $$
  

- 每个叶子节点，都有相同的深度，即 **树的高度 h**
- 每个节点所包含的关键字个数有上界和下界。用一个被称为B树最小度数（minmum degree）的固定树来固定整数 t(t >= 2)来表示这些界：
  1. 除了根节点以外的每一个节点必须至少有 t -1 个关键字。因此，除了根节点以外的每个内部节点至少有t 个孩子。如果树为非空，根节点至少有一个关键字
  2. 每个节点最多有 2t-1 个关键字，因此，一个内部节点至多可有 2t 个孩子。当一个节点恰好有2t-1个关键字，称该节点为full. t =2 时的B树是非常简单的。每个内部节点有2、3、或 4个孩子，即一颗2-3-4树。



# B Tree 的优势 

**B Tree 最大的优势：相对较小的磁盘存取次数.**
为什么呢？因为大部分的操作的时间复杂是和 B Tree 的高度成正比的 (每次查询一个节点都需要一次磁盘访问，例如查询一个叶子节点需要访问 h (高度) 个节点).

B Tree 的高度 (具体证明见书算法导论，其实也是等比数列的求和):
$$
\log_t\frac{n+1}{2}
$$


而二叉树的高度为
$$
\log_2n
$$


在n相同的情况下，即使t=2,B Tree的高度依旧比二叉树要低，而在实际情况中t的值只会比2大的多。所以其高度也就小的多。所以当这种结构运用于磁盘的读取时，其效率远远高于二叉树。



# 搜索B 树

B-Tree-Search(x,k)

```
i = 1
while i <= x.n and k > x.keyi
    i = i +1
if i <= x.n and k == x.keyi
	return (x,i)
elseif x.leaf
	return NIL
else DISK-READ(x,ci)
	return B-Tree-Search(x.ci,k)
```



伪代码说明

- 1 到 3 行 在本节点内查找关键字
- 4 到 5 行 确认是否查找到节点
- 6 到 7 行 确认判断 该节点是否为叶子节点，如果为叶子节点，结束遍历
- 8 到 9 行 对孩子节点执行必要的DISK-READ,递归搜索x 的相应子树。（主要这里是一个for循环）



## 分裂树的节点



过程 B-TREE-SPLIT-CHILD 的输入是一个非满的内部节点 $ x $和一个使得 $ x.c_i $为满子节点的下标i。该过程吧这个子节分裂成两个，并调整x,让其包含多出来的孩子。要分裂一个满的根，首先要让根成为一个新的空根节点，这样才能使用B-TREE-SPLIT-CHILD。树的高度增加1；分裂是树长高的唯一途径

```
z = ALLOCATE-NODE()
y = x.ci
z.leaf = y.leaf
z.n = t - 1
for j = 1 to t -1 
	z.keyj = y.keyj+t
if not y.leaf   // y 是内部节点
	for j = 1 to t 
			z.cj = y.cj+t
y.n = t-1
for j = x.n+1 downto i+1
	x.cj+1 = x.cj
	
x.keyi = y.keyt
x.n = x.n+1
```

